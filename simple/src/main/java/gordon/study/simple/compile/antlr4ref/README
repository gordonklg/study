学习资料：《Antlr4权威指南》（京东读书）

读书笔记
第2章 纵观全局
ANTLR解决歧义问题的方法是：选择所有匹配的备选分支中的第一条
在词法分析器中，ANTLR解决歧义问题的方法是：匹配在语法定义中最靠前的那条词法规则。词法分析器会匹配可能的最长字符串来生成一个词法符号。


第4章 快速指南
·语法包含一系列描述语言结构的规则。这些规则既包括类似stat和expr的描述语法结构的规则，也包括描述标识符和整数之类的词汇符号（词法符号）的规则。
·语法分析器的规则以小写字母开头。
·词法分析器的规则以大写字母开头。
·使用|来分隔同一个语言规则的若干备选分支，使用圆括号把一些符号组合成子规则。例如，子规则（'*'|'/'）匹配一个乘法符号或者一个除法符号。
·语法导入。import。
·标签以#开头，放置在一个备选分支的右侧。标签使每个备选分支都有不同的访问器方法，获得不同的事件。

访问器机制和监听器机制的最大的区别在于，监听器的方法会被ANTLR提供的遍历器对象自动调用，而在访问器的方法中，必须显式调用visit方法来访问子节点。
忘记调用visit（）的后果就是对应的子树将不会被访问。


第5章 设计语法
四种抽象的计算机语言模式：
·序列：即一列元素，例如一个数组初始化语句中的值。
·选择：在多种可选方案中做出选择，例如编程语言中的不同种类的语句。
·词法符号依赖：一个词法符号需要和某处的另外一个词法符号配对，例如左右括号匹配。
·嵌套结构：一种自相似的语言结构，例如编程语言中的嵌套算术表达式或者嵌套语句块。
为实现以上模式，我们的语法规则只需要可选方案、词法符号引用和规则引用即可（巴克斯-诺尔范式，Backus-Naur-Format，BNF）。尽管如此，为方便起见，
我们还是将这些元素划分为子规则。子规则是用括号包围的内联规则。我们可以用以下符号标记子规则，用于指明其中的语法片段出现的次数：
可选（？）、出现0次或多次（*）、至少一次（+）（扩展巴克斯-诺尔范式，Extended Backus-Naur-Format，EBNF）。

语法分析树的非叶子节点代表了规则，而叶子节点代表了词法符号。一条从根节点到任意节点的路径代表了对应的规则调用栈
（同时也是ANTLR自动生成的递归下降语法分析器的调用栈）。因此，代表递归调用的路径上就会存在对多个相同规则的引用。
我喜欢将一个规则节点看作它的后代子树的标签：因为根节点是expr，所以整棵树就是一个表达式（expression）。

ANTLR通过优先选择位置靠前的备选分支来解决歧义问题，这隐式地允许我们指定运算符优先级。

使用assoc选项手工指定结合性。

ANTLR4可以处理直接左递归。（左递归是指在某个备选分支的最左侧以直接或者间接方式调用了自身）。无法处理间接左递归。

ANTLR对这种混合了词法规则和文法规则的语法文件的处理机制：
首先，ANTLR从文法规则中筛选出所有的字符串常量，并将它们和词法规则放在一起。'enum'这样的字符串常量被隐式定义为词法规则，然后
放置在文法规则之后、显式定义的词法规则之前。ANTLR词法分析器解决歧义问题的方法是优先使用位置靠前的词法规则。这意味着，ID规则
必须定义在所有的关键字规则之后，在上面的例子中，它在FOR规则之后。ANTLR将为字符串常量隐式生成的词法规则放在显式定义的词法规则
之前，所以它们总是拥有最高的优先级。因此，在本例中，'enum'被自动赋予了比ID更高的优先级。

将一条规则声明为fragment可以告诉ANTLR，该规则本身不是一个词法符号，它只会被其他的词法规则使用。这意味着我们不能在文法规则中引用它们。

ANTLR通过标准正则表达式的标记（？后缀）提供了对非贪婪匹配子规则（nongreedy subrule）的支持。非贪婪匹配的基本含义是：“获取一些字符，
直到发现匹配后续子规则的字符为止”。更准确的描述是，在保证整个父规则完成匹配的前提下，非贪婪的子规则匹配数量最少的字符。
与之相反，.*是贪婪的，因为它贪婪地消费掉一切匹配的字符（在本例中就是匹配通配符.的字符）。


















