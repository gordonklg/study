更好的方案：如果线程要求的条件（转出账本和转入账本同在文件架上）不满足，则线程阻塞自己，进入等待状态；当线程要求的条件
（转出账本和转入账本同在文件架上）满足后，通知等待的线程重新执行。其中，使用线程阻塞的方式就能避免循环等待消耗 CPU 的问题。

用 synchronized 配合 wait()、notify()、notifyAll() 实现等待-通知机制。

当有一个线程进入临界区后，其他线程就只能进入图中左边的等待队列【锁标志等待池】里等待。这个等待队列和互斥锁是一对一的关系，每个互斥锁都有自己独立的等待队列。
           等待队列-----> synchronized() {
                             ....
                             if(条件不满足)
                                 wait()  -----------> 等待队列
                             ....
                         }
当一个线程进入临界区后，由于某些条件不满足，需要进入等待状态，Java 对象的 wait() 方法就能够满足这种需求。如上图所示，当调用 wait() 方法后，
当前线程就会被阻塞，并且进入到右边的等待队列【对象等待池】中，这个等待队列也是互斥锁的等待队列。线程在进入等待队列的同时，会释放持有的互斥锁，线程释放锁后，
其他线程就有机会获得锁，并进入临界区了。
           等待队列-----> synchronized() {
                             ....
                             if(条件满足)
                                 notify()  -----------> 等待队列
                             ....
                         }
当条件满足时调用 notify()，会通知等待队列（互斥锁的等待队列）中的线程，告诉它条件曾经满足过。【从对象等待池中移出任意一个线程并放入锁标志等待池中】

注意点：
1. wait调用需要在while循环中
2. 一般用notifyAll而非notify
（参考 ManagedAccount.java 和 AccountAllocator.java）




