## 什么是 Java 内存模型？
导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最直接的办法就是禁用缓存和编译优化，但是这样问题
虽然解决了，我们程序的性能可就堪忧了。
合理的方案应该是按需禁用缓存以及编译优化。
Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。

## 使用 volatile 的困惑
volatile 最原始的意义是禁用 CPU 缓存。例如，我们声明一个 volatile 变量 volatile int x = 0，它表达的是：告诉编译器，对
这个变量的读写，不能使用 CPU 缓存，必须从内存中读取或者写。
按这个意义，VolatileExample.java 可能读到 x 的值为 0
【代码执行带 volatile 修饰的这一行代码（v=true），会将目前缓存的刷进内存，同时，通过总线机制，让别的CPU缓存失效，这样就
保证了，volatile这个变量的写操作对别的线程一定是可见的，这时候别的线程读取x的值，如果x=42没有被重排序到v=true后面，那么
别的线程是能读到42的，但是如果被编译重排序了，这时候，x=42还没执行，别的线程读到的是0，但是从代码的顺序来看，x的赋值操作
是发生了。所以就造成了错误，代码的执行顺序没有按照程序员的意志就行执行。】

Java 内存模型在 1.5 版本对 volatile 语义进行了增强：

## Happens-Before 规则
Happens-Before 表示：前面一个操作的结果对后续操作是可见的。

- 程序的顺序性规则：在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作
- volatile 变量规则：对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作
- 传递性：如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。

以上3条保证了 VolatileExample.java 读到的 x 的值必然为 42

- 管程中锁的规则：对一个锁的解锁 Happens-Before 于后续对这个锁的加锁
- 线程 start() 规则：主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作
- 线程 join() 规则：主线程 A 等待子线程 B 完成，当子线程 B 完成后，主线程能够看到子线程的操作（对共享变量的操作）

## 被我们忽视的 final
final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。
【需另找资源理解】







